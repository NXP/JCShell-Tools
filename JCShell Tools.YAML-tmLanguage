# [PackageDev] target_format: plist, ext: tmLanguage
---

name: JCShell Tools
scopeName: source.jcsh
fileTypes: [jcsh]
uuid: 18d303a3-9fdd-4503-8eba-e8c0b283ddc1

# Define here variables to be re-used in the file for ease of modification
yaml_variable: &CMD_LIST_SLASH_BUILTIN
  match: (?<=^|:|\()\s*(?:(/)|([@\-]))(app|applet|atr|c-v|cap-clear|cap-del-auth|cap-extrdt-auth|cap-info|cap-inst-auth|cap-load-auth|cap-reg-update|cap-sign|card|change-protocol|channel|clear-vars|close|echo|error|exchange-poweroff|exchange-warmreset|exec|expr|glob|identify|l-r|l-v|list-readers|list-vars|manage-channel|mode|printf|r-echo|register|s-v|select|send|set-channel|set-var|sleep|start-timer|stop-timer|term|terminal)(?=\s|\)|#|$)
yaml_variable: &CMD_LIST_BUILTIN
  match: (?<=^|:|\()\s*([@\-])?(>|\?|auth|card-info|delete|delete-key|ext-auth|extradite|flush|get-cplc|get-crs-state|get-data|get-sd-cert|help|init-upd|init-update|install|internal-authenticate|ls|mutual-authenticate|perform-security-operation|personalize|print-key|put-key|put-key-ecc|put-keyset|put-pub-key|quit|registry-update|select|send|session-info|set-applet|set-crs-state|set-key|set-scp|set-sd-state|set-security|set-state|store-aid|store-data|store-keyset|upload|upload-install-make-selectable|version)(?=\s|\)|#|$)
yaml_variable: &CMD_LIST_CRYPTO
  match: (?<=^|:|\()\s*([@\-])?(decrypt|encrypt|hash|keygen|mac|pad|sign|unpad)(?=\s|\)|#|$)
yaml_variable: &CMD_LIST_GP
  match: (?<=^|:|\()\s*([@\-])?(delete|extradite|install|registry-update|upload)(?=\s|\)|#|$)
yaml_variable: &VAR_LIST_BUILTIN
  match: (?<=\{)\s*(?:[Aa]rgv|[Cc]hannel|ECC_CURVEPARAM_A|ECC_CURVEPARAM_B|ECC_CURVEPARAM_G|ECC_CURVEPARAM_N|ECC_CURVEPARAM_P|ECC_SharedSecret|exec\.dir|exec\.errorlog|exec\.output|JCOPDIR|KEY_ECC_PrivateKey|KEY_ECC_PublicKeyX|KEY_ECC_PublicKeyY|KEY_RSA_PrivateKey|KEY_RSA_PrivateKey_dP|KEY_RSA_PrivateKey_dQ|KEY_RSA_PrivateKey_P|KEY_RSA_PrivateKey_PQ|KEY_RSA_PrivateKey_Q|KEY_RSA_PublicKey|last\.apdu\.executiontime|last\.apdu\.executiontime\.unit|last\.error|last\.errorlog|last\.executiontime|last\.executiontime\.unit|last\.response\.data|last\.response\.status|last\.return|logfile\.list|[Pp]ath|[Pp]lugin|[Rr]andom|[Rr]esponse|script\.dir|script\.line|script\.name|scrtimer\.exec\.time|SIGNATURE_ECDSA_R|SIGNATURE_ECDSA_S|SIGNATURE_RSA|timer\.execution\.time|timer\.id|[Tt]erminal|[Tt]ime|VERIFY_SIGN|[Vv]ersion)\s*(?=[\[;\}])
yaml_variable: # Clear the node (variable)

patterns:
- include: '#empty-line'
- include: '#comment'
- include: '#label'
- include: '#line-continuation'
- include: '#comment-line'
- include: '#function-definition'
- include: '#if-block'
- include: '#while-block'
- include: '#for-block'
- include: '#try-block'
- include: '#goto-statement'
- include: '#assignment-operator'
- include: '#assignment-command'
- include: '#continued-line'
- include: '#call'
- include: '#invalid-character'

repository:
  empty-line:
    patterns:
    - comment: Line containing only whitespace
      name: meta.empty.source.jcsh
      match: ^\s*(\\)?$

  comment-line:
    patterns:
    - comment: Line containing only whitespace and a single-line comment starting
        with '#'
      name: meta.comment.line.full.source.jcsh
      match: ^\s*(#)(.*)$
      captures:
        '1': {name: comment.line.number-sign.source.jcsh}
        '2': {name: comment.line.source.jcsh}

  comment:
    patterns:
    - comment: Single-line comment starting with '#'
      name: meta.comment.line.source.jcsh
      match: \s*(?<!\S)(#)(.*)$
      captures:
        '1': {name: comment.line.number-sign.source.jcsh}
        '2': {name: comment.line.source.jcsh}

  invalid-character:
    patterns:
    - comment: Match anything not matched yet
      name: invalid.character.source.jcsh
      match: .

  line-continuation:
    patterns:
    - comment: Line continuation
      name: meta.line-continuation.source.jcsh
      begin: (\\)\s*$
      beginCaptures:
        '1': {name: punctuation.line-continuation.source.jcsh}
      end: $
      patterns:
      - include: '#invalid-character'

  continued-line:
    patterns:
    - comment: Continued line
      name: meta.continued-line.source.jcsh
      begin: ^\s*(?=")
      end: (?=$)
      patterns:
      - begin: \s*(?=")
        end: (?<=\S)(?=\s|\)|$|\\)
        patterns:
        - include: '#string'
        - include: '#invalid-character'

  label:
    patterns:
    - comment: Leading label that can be jumped to using goto. Labels can be placed at the beginning of any line and cannot contain variables
      name: meta.control.label.definition.source.jcsh
      match: ^\s*(\w[\w\-\.]*)\s*(:)
      captures:
        '1': {name: keyword.control.label.definition.source.jcsh}
        '2': {name: punctuation.definition.label.source.jcsh}

  assignment-command:
    patterns:
    - comment: Variable assignment with explicit command, only a label can be placed in front
      name: meta.assignment.source.jcsh
      begin: (?:^|(?<=.:))\s*(/set-var|/s-v)\s((?:\s*(?:-d|--def|-g|--global|-q|--quote)\s)*)
      beginCaptures:
        '1': {name: keyword.assignment.command.source.jcsh}
        '2': {name: variable.parameter.flag.assignment.source.jcsh}
      end: (?=(?:\s#[^\(])|$|\\)
      patterns:
      - comment: Match the newly defined variable name (consume up to the next space). We have to rematch the beginning of the line to make sure we only take the first word after the space (and that the regex is not applied to each word on the line)
        begin: (?<=(?:/set-var\s|/s-v\s|-d\s|--def\s|-g\s|--global\s|-q\s|--quote\s))\s*
        end: (?<=\S)\s+(?=.*|(?:\s#[^\(])|$|\\)
        patterns:
        - comment: Handle the subscript first (array '[]')
          include: '#subscript'
        - comment: Then the newly defined variable name
          include: '#assignment-name'
      - comment: Process the value assigned (after the first space)
        include: '#expression'
      - comment: Spaces are legit for variable assignment
        match: \s
      - include: '#invalid-character'

  assignment-operator:
    patterns:
    - comment: "Variable assignment with operator ('='). Avoid assignment detection if the following operators are formed with the '=': <= >= == != =~. Only a label can be placed in front"
      name: meta.assignment.source.jcsh
      begin: (?:^|(?<=.:))\s*(?=.*[^<>\=\!]\=[^~\=])
      end: (?<=.)\s*(?=(?:\s#[^\(])|$|\\)
      patterns:
      - comment: Match the newly defined variable name (consume up to the '=')
        begin: (?<=(?:.|^))(?=.*\=)
        end: (=)(?=.|(?:\s#[^\(])|$|\\)
        endCaptures:
          '1': {name: keyword.assignment.operator.source.jcsh}
        patterns:
        - comment: Handle the subscript first (array '[]')
          include: '#subscript'
        - comment: Then the newly defined variable name
          include: '#assignment-name'
      - comment: Process the value assigned (after the '=')
        include: '#expression'
      - comment: Spaces are legit for variable assignment
        match: \s
      - include: '#invalid-character'

  assignment-name:
    patterns:
    - comment: Name of the variable newly created (that can contains variables calls inside)
      patterns:
      - include: '#variable'
      - include: '#nested-call'
      - match: \S
        name: variable.assigned.source.jcsh
      - include: '#invalid-character'

  variable:
    patterns:
    - comment: Bracket-style variable reference
      name: meta.reference.variable.source.jcsh
      begin: (\$)(\{)
      beginCaptures:
        '1': {name: punctuation.definition.reference.variable.head.source.jcsh}
        '2': {name: punctuation.definition.reference.variable.begin.source.jcsh}
      end: \}
      endCaptures:
        '0': {name: punctuation.definition.reference.variable.end.source.jcsh}
      patterns:
      - include: '#subscript'
      - include: '#plugin-modifier'
      - include: '#modifier'
      - include: '#variable-name'
      - include: '#invalid-character'

  subscript:
    patterns:
    - comment: Variable subscript (array '[]')
      begin: (\[)
      beginCaptures:
        '1': {name: punctuation.definition.subscript.begin.source.jcsh}
      end: (\])
      endCaptures:
        '1': {name: punctuation.definition.subscript.end.source.jcsh}
      patterns:
      - comment: Inside the '[]' (no space allowed)
      - match: \*
        name: punctuation.subscript.content.asterisk.source.jcsh
      - include: '#expression'
      - match: \#
        name: punctuation.subscript.content.number-sign.source.jcsh
      - include: '#invalid-character'

  variable-name:
    patterns:
    - comment: Variable name. May contain replaced variables and interpolations
      name: meta.variable.name.source.jcsh
      begin: (?<=\{)
      end: (?=[:\[;\}])
      patterns:
      - include: '#variable-name-builtin'
      - include: '#variable-name-positional'
      - include: '#variable-name-environment'
      - include: '#variable-name-user'
      - include: '#invalid-character'

  variable-name-builtin:
    patterns:
    - comment: Name of a JCShell built-in variable.
      name: support.variable.name.builtin.source.jcsh
      <<: *VAR_LIST_BUILTIN

  variable-name-positional:
    patterns:
    - comment: Name of a positional variable
      name: support.variable.name.positional.source.jcsh
      match: (?<=\{)\d+(?=[\[;\}])

  variable-name-environment:
    patterns:
    - comment: Name of an environment variable (starting with '*')
      name: meta.variable.name.environment.source.jcsh
      match: (?<=\{)(\*)([\w.]+)(?=[\[;\}])
      captures:
        '1': {name: punctuation.definition.variable.name.environment.source.jcsh}
        '2': {name: variable.name.environment.source.jcsh}

  variable-name-user:
    patterns:
    - comment: User-defined variable name
      name: meta.variable.name.user.source.jcsh
      begin: (?<=\{)
      end: \s*(?=[:\[;\}])
      patterns:
      - include: '#variable'
      - include: '#nested-call'
      - match: \S
        name: variable.name.user.source.jcsh
      - include: '#invalid-character'

  modifier:
    patterns:
    - comment: Variable modifier
      name: meta.variable.modifier.source.jcsh
      begin: ;
      beginCaptures:
        '0': {name: punctuation.separator.variable.modifier.source.jcsh}
      end: (?=[;\}])
      patterns:
      - include: '#builtin-modifier'
      - include: '#variable'
      - include: '#nested-call'
      - name: keyword.modifier.user.surrounding.source.jcsh
        match: \s*\w[\w\-\.]*\s*
      - include: '#invalid-character'

  builtin-modifier:
    patterns:
    - comment: Built-in variable modifier name
      name: meta.modifier.name.builtin.source.jcsh
      match: (?<=;)\s*([Dd]irname|[Ff]ilename|[Bb]asename|[Ee]xtension|[Ll]|[Qq]|[Qq]q|[Ll]c|[Uu]c)\s*(?=[;\}])
      captures:
        '0': {name: keyword.modifier.builtin.source.jcsh}
    - comment: Built-in hex variable modifier
      begin: (?<=;)\s*(h)\s*
      beginCaptures:
        '1': {name: keyword.modifier.builtin.source.jcsh}
      end: \s*(?=[;\}])
      patterns:
      - include: '#variable'
      - include: '#nested-call'
      - name: constant.numeric.decimal.hex-modifier.surrounding.source.jcsh
        match: \d*
      - include: '#invalid-character'
    - comment: Built-in substring variable modifier
      begin: (?<=;)\s*(s)
      beginCaptures:
        '1': {name: keyword.modifier.builtin.source.jcsh}
      end: \s*(?=[;\}])
      patterns:
      - comment: First argument of substring variable modifier
        begin: (?<=s)\s*
        end: \s*(?=[,;\}])
        patterns:
        - include: '#variable'
        - include: '#nested-call'
        - name: constant.numeric.decimal.substring-modifier.offset.surrounding.source.jcsh
          match: \d*
        - include: '#invalid-character'
      - comment: Second argument of substring variable modifier
        begin: (,)\s*
        beginCaptures:
          '1': {name: punctuation.separator.variable.modifier}
        end: \s*(?=[;\}])
        patterns:
        - include: '#variable'
        - include: '#nested-call'
        - name: constant.numeric.decimal.substring-modifier.length.surrounding.source.jcsh
          match: \d*
        - include: '#invalid-character'
      - include: '#invalid-character'
    - comment: Built-in assigned variable modifier
      begin: (?<=;)\s*(fmt|len)\s*(\=)
      beginCaptures:
        '1': {name: keyword.modifier.builtin.source.jcsh}
        '2': {name: keyword.assignment.operator.source.jcsh}
      end: \s*(?=[;\}])
      patterns:
      - include: '#variable'
      - name: string.unquoted.assigned-modifier.surrounding.source.jcsh
        match: .
      - include: '#invalid-character'

  plugin-modifier:
    patterns:
    - comment: Modifier for accessing plugin variables
      name: meta.variable.plugin-modifier.source.jcsh
      begin: ':'
      beginCaptures:
        '0': {name: punctuation.separator.variable.modifier.plugin.source.jcsh}
      end: (?=[\[;\}])
      patterns:
      - include: '#variable'
      - include: '#nested-call'
      - name: support.variable.name.plugin.surrounding.source.jcsh
        match: \s*\w[\w\-\.]*\s*
      - include: '#invalid-character'

  call:
    patterns:
    - comment: Call to a built-in command, function or external script. Only a label can be placed in front
      name: meta.control.call.source.jcsh
      begin: (?:^|(?<=.:))
      end: (?<=.)\s*(?=\)|#[^//(]|$|\\)
      patterns:
      - include: '#callable'
      - include: '#argument'
      - match: \s
      - include: '#invalid-character'

  callable:
    patterns:
    - comment: Callable built-in command, function or external script
      name: meta.callable.source.jcsh
      begin: (?<=^|:|\()
      end: (?<=[\w\}\)\?>])(?=\s|\)|#|$)
      patterns:
      - comment: JCShell Crypto Plugin command
        name: meta.support.function.plugin.crypto.source.jcsh
        <<: *CMD_LIST_CRYPTO
        captures:
          '1': {name: punctuation.call-modifier.builtin.source.jcsh}
          '2': {name: support.function.plugin.crypto.source.jcsh}
      - comment: JCShell Provider Security Domain Plugin command
        name: meta.support.function.plugin.psd.source.jcsh
        <<: *CMD_LIST_GP
        captures:
          '1': {name: punctuation.call-modifier.builtin.source.jcsh}
          '2': {name: support.function.plugin.psd.source.jcsh}
      - comment: JCShell built-in slash command
        name: meta.support.function.builtin.slash.source.jcsh
        <<: *CMD_LIST_SLASH_BUILTIN
        captures:
          '1': {name: punctuation.definition.callable.builtin.slash.source.jcsh}
          '2': {name: punctuation.call-modifier.builtin.source.jcsh}
          '3': {name: support.function.builtin.slash.source.jcsh}
      - comment: JCShell built-in command
        name: meta.support.function.builtin.source.jcsh
        <<: *CMD_LIST_BUILTIN
        captures:
          '1': {name: punctuation.call-modifier.builtin.source.jcsh}
          '2': {name: support.function.builtin.source.jcsh}
      - comment: User-defined callable
        name: meta.callable.user.source.jcsh
        begin: (?<=^|:|\()
        end: (?<=[\}\)\w])(?=\s|\)|#|$)
        patterns:
        - match: (?<=^|:|\()\s*([@\-])?
          captures:
            '1': {name: punctuation.call-modifier.user.source.jcsh}
        - include: '#variable'
        - include: '#nested-call'
        - match: ([\w\/][\w\-\/\.\\]*)
          captures:
            '1': {name: entity.name.function.surrounding.source.jcsh}
        - include: '#invalid-character'
      - include: '#invalid-character'

  argument:
    patterns:
    - comment: Argument of a call
      name: meta.argument.source.jcsh
      begin: (?<=\s)\s*
      end: (?<=\S)(?=\s|\)|$|\\)
      patterns:
      - include: '#flag'
      - include: '#expression'
      - include: '#invalid-character'

  flag:
    patterns:
    - comment: Flag argument of a call
      name: meta.flag.source.jcsh
      begin: (?<=\s)(--?)(?=\w)
      beginCaptures:
        '1': {name: punctuation.definition.flag.source.jcsh}
      end: (?<=[\}\)\w])(?=\)|\s|#|$)
      patterns:
      - include: '#variable'
      - include: '#nested-call'
      - name: variable.parameter.flag.surrounding.source.jcsh
        match: \w[\w\-\.]*
      - include: '#invalid-character'

  expression:
    patterns:
    - include: '#string'
    - include: '#variable'
    - include: '#nested-call'
    - include: '#number'
    - include: '#operator'
    - name: string.unquoted.expression.surrounding.source.jcsh
      match: '[\w\-\.,\=!:;]+'
    - begin: (#)?(\()
      beginCaptures:
        '1': {name: punctuation.parentheses.modifier.source.jcsh}
        '2': {name: punctuation.parentheses.begin.source.jcsh}
      end: \)
      endCaptures:
        '0': {name: punctuation.parentheses.end.source.jcsh}
      patterns:
      - include: '#expression'

  nested-call:
    patterns:
    - comment: Nested call ('$()')
      name: meta.nested-call.source.jcsh
      begin: (\$)(\()
      beginCaptures:
        '1': {name: punctuation.definition.nested-call.head.source.jcsh}
        '2': {name: punctuation.definition.nested-call.begin.source.jcsh}
      end: \)
      endCaptures:
        '0': {name: punctuation.definition.nested-call.end.source.jcsh}
      patterns:
      - name: meta.nested-call.content.source.jcsh
        begin: (?<=\()
        end: (?<=.)\s*(?=\)|#[^\(]|$|(\\))
        patterns:
        - include: '#callable'
        - include: '#argument'
        - match: \s
        - include: '#invalid-character'
      - include: '#invalid-character'

  number:
    patterns:
    - name: constant.numeric.hexadecimal.source.jcsh
      match: (?<!\w)(0x)?[\da-fA-F]+(?![\w.])
    - name: constant.numeric.decimal.source.jcsh
      match: (?<!\w)\d+(?![\w.])

  string:
    patterns:
    - comment: Single-quoted string literal without variable replacement and interpolation
      name: meta.string.source.jcsh
      begin: "'"
      beginCaptures:
        '0': {name: punctuation.definition.string.single.begin.source.jcsh}
      end: "'"
      endCaptures:
        '0': {name: punctuation.definition.string.single.end.source.jcsh}
      patterns:
      - name: constant.character.escape.source.jcsh
        match: \\['\\]
      - name: string.quoted.single.surrounding.source.jcsh
        match: .
    - comment: Double-quoted string literal with variable replacement and interpolation
      name: meta.string.source.jcsh
      begin: '"'
      beginCaptures:
        '0': {name: punctuation.definition.string.double.begin.source.jcsh}
      end: '"'
      endCaptures:
        '0': {name: punctuation.definition.string.double.end.source.jcsh}
      patterns:
      - include: '#variable'
      - include: '#nested-call'
      - name: constant.character.escape.source.jcsh
        match: \\[\$"\\]
      - name: string.quoted.double.surrounding.source.jcsh
        match: .

  operator:
    patterns:
    - name: keyword.operator.source.jcsh
      match: (-|\*|/|%|\+|<<|>>>|>>|<=|<|>=|>|==|!=|!|=~|~|&|\^|\||\.\.|\?)

  if-block:
    patterns:
    - comment: If block, only a label can be placed in front
      name: meta.control.if.source.jcsh
      begin: (?:^|(?<=.:))\s*(if)(?=\s+\S+.*$|(\\))
      beginCaptures:
        '1': {name: keyword.control.if.source.jcsh}
      end: ^\s*(end)\s*(?:\s(#)(.*))?$
      endCaptures:
        '1': {name: keyword.control.if.end.source.jcsh}
        '2': {name: comment.line.number-sign.source.jcsh}
        '3': {name: comment.line.source.jcsh}
      patterns:
      - include: '#if-expression'
      - include: '#elseif-clause'
      - include: '#else-clause'
      - include: $self

  if-expression:
    patterns:
    - begin: (?<=if)\s+
      end: \s*(?:\s(#)(.*))?$|(\\)
      endCaptures:
        '1': {name: comment.line.number-sign.source.jcsh}
        '2': {name: comment.line.source.jcsh}
      patterns:
      - include: '#expression'
      - match: \s
      - include: '#invalid-character'

  else-clause:
    patterns:
    - comment: Else clause
      name: meta.control.else.source.jcsh
      match: ^\s*(else)\s*(?:\s(#)(.*))?$|(\\)
      captures:
        '1': {name: keyword.control.else.source.jcsh}
        '2': {name: comment.line.number-sign.source.jcsh}
        '3': {name: comment.line.source.jcsh}

  elseif-clause:
    patterns:
    - comment: Elseif clause
      name: meta.control.elseif.jcsh
      begin: ^\s*(elseif)\s+
      beginCaptures:
        '1': {name: keyword.control.elseif.jcsh}
      end: \s*(?:\s(#)(.*))?$|(\\)
      endCaptures:
        '1': {name: comment.line.number-sign.source.jcsh}
        '2': {name: comment.line.source.jcsh}
      patterns:
      - include: '#expression'
      - match: \s
      - include: '#invalid-character'

  try-block:
    patterns:
    - comment: Try block, only a label can be placed in front
      name: meta.control.try.source.jcsh
      begin: (?:^|(?<=.:))\s*(try)\s*(?:\s(#)(.*))?$|(\\)
      beginCaptures:
        '1': {name: keyword.control.try.source.jcsh}
        '2': {name: comment.line.number-sign.source.jcsh}
        '3': {name: comment.line.source.jcsh}
      end: ^\s*(end)\s*(?:\s(#)(.*))?$
      endCaptures:
        '1': {name: keyword.control.try.end.source.jcsh}
        '2': {name: comment.line.number-sign.source.jcsh}
        '3': {name: comment.line.source.jcsh}
      patterns:
      - include: '#catch-clause'
      - include: $self

  catch-clause:
    comment: Catch clause
    name: meta.control.catch.source.jcsh
    begin: ^\s*(catch)\s+
    beginCaptures:
      '1': {name: keyword.control.catch.source.jcsh}
    end: \s*(?:\s(#)(.*))?$|(\\)
    endCaptures:
      '1': {name: comment.line.number-sign.source.jcsh}
      '2': {name: comment.line.source.jcsh}
    patterns:
    - include: '#expression'
    - match: \s
    - include: '#invalid-character'

  for-block:
    patterns:
    - comment: For block, only a label can be placed in front
      name: meta.control.for.source.jcsh
      begin: (?:^|(?<=.:))\s*(for)(?=\s+\S+.*$|(\\))
      beginCaptures:
        '1': {name: keyword.control.for.source.jcsh}
      end: ^\s*(end)\s*(?:\s(#)(.*))?$
      endCaptures:
        '1': {name: keyword.control.for.end.source.jcsh}
        '2': {name: comment.line.number-sign.source.jcsh}
        '3': {name: comment.line.source.jcsh}
      patterns:
      - include: '#for-expression'
      - include: '#break-statement'
      - include: '#continue-statement'
      - include: $self

  for-expression:
    patterns:
    - begin: (?<=for)\s+(\w[\w\-\.]*)
      beginCaptures:
        '1': {name: variable.parameter.iterator.source.jcsh}
      end: \s*(?:\s(#)(.*))?$
      endCaptures:
        '1': {name: comment.line.number-sign.source.jcsh}
        '2': {name: comment.line.source.jcsh}
      patterns:
      - include: '#expression'
      - match: \s
      - include: '#invalid-character'

  break-statement:
    patterns:
    - comment: Break statement, only a label can be placed in front
      name: meta.control.break.source.jcsh
      match: (?:^|(?<=.:))\s*(break)(?:\s+(\w[\w\-\.]*))?\s*(?:\s(#)(.*))?$|(\\)
      captures:
        '1': {name: keyword.control.break.source.jcsh}
        '2': {name: keyword.control.label.target.source.jcsh}
        '3': {name: comment.line.number-sign.source.jcsh}
        '4': {name: comment.line.source.jcsh}

  continue-statement:
    patterns:
    - comment: Continue statement, only a label can be placed in front
      name: meta.control.continue.source.jcsh
      match: (?:^|(?<=.:))\s*(continue)(?:\s+(\w[\w\-\.]*))?\s*(?:\s(#)(.*))?$|(\\)
      captures:
        '1': {name: keyword.control.continue.source.jcsh}
        '2': {name: keyword.control.label.target.source.jcsh}
        '3': {name: comment.line.number-sign.source.jcsh}
        '4': {name: comment.line.source.jcsh}

  while-block:
    patterns:
    - comment: While block, only a label can be placed in front
      name: meta.control.while.source.jcsh
      begin: (?:^|(?<=.:))\s*(while)(?=\s+\S+.*$|(\\))
      beginCaptures:
        '1': {name: keyword.control.while.source.jcsh}
      end: ^\s*(end)\s*(?:\s(#)(.*))?$
      endCaptures:
        '1': {name: keyword.control.while.end.source.jcsh}
        '2': {name: comment.line.number-sign.source.jcsh}
        '3': {name: comment.line.source.jcsh}
      patterns:
      - include: '#while-expression'
      - include: '#break-statement'
      - include: '#continue-statement'
      - include: $self

  while-expression:
    patterns:
    - begin: (?<=while)\s+
      end: \s*(?:\s(#)(.*))?$|(\\)
      endCaptures:
        '1': {name: comment.line.number-sign.source.jcsh}
        '2': {name: comment.line.source.jcsh}
      patterns:
      - include: '#expression'
      - match: \s
      - include: '#invalid-character'

  function-definition:
    patterns:
    - comment: DEFUN function definition
      name: meta.section.function-definition.source.jcsh
      begin: ^\s*(DEFUN)\s+(\w[\w\-]*)((?:\s+\w[\w\-\.]*)*)\s*(?:\s(#)(.*))?$|(\\)
      beginCaptures:
        '1': {name: keyword.function.definition.begin.source.jcsh}
        '2': {name: entity.name.function.definition.source.jcsh}
        '3': {name: variable.parameter.definition.source.jcsh}
        '4': {name: comment.line.number-sign.source.jcsh}
        '5': {name: comment.line.source.jcsh}
      end: ^\s*(END)\s*(?:\s(#)(.*))?$
      endCaptures:
        '1': {name: keyword.function.definition.begin.source.jcsh}
        '2': {name: comment.line.number-sign.source.jcsh}
        '3': {name: comment.line.source.jcsh}
      patterns:
      - include: '#return-statement'
      - include: $self

  return-statement:
    patterns:
    - comment: Return statement, only a label can be placed in front
      name: meta.control.return.source.jcsh
      begin: (?:^|(?<=.:))\s*(return)
      beginCaptures:
        '1': {name: keyword.control.return.source.jcsh}
      end: \s*(?=(\s#)|$|\\)
      patterns:
      - include: '#expression'
      - match: \s
      - include: '#invalid-character'

  goto-statement:
    patterns:
    - comment: Goto statement, only a label can be placed in front
      name: meta.control.goto.source.jcsh
      match: (?:^|(?<=.:))\s*(goto)\s+(\w[\w\-\.]*)\s*(?:\s(#)(.*))?$|(\\)
      captures:
        '1': {name: keyword.control.goto.source.jcsh}
        '2': {name: keyword.control.label.target.source.jcsh}
        '3': {name: comment.line.number-sign.source.jcsh}
        '4': {name: comment.line.source.jcsh}

...
