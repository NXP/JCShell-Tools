# [PackageDev] target_format: plist, ext: tmLanguage
---

name: JCShell Tools
scopeName: source.jcsh
fileTypes: [jcsh]
uuid: 18d303a3-9fdd-4503-8eba-e8c0b283ddc1
version: 1.0.0

# Define here variables to be re-used in the file for ease of modification
yaml_variable: &CMD_LIST_SLASH_BUILTIN
  match: (?<=^|:|\()\s*(?:(/)|([@\-]))(app|applet|atr|c-v|cap-clear|cap-del-auth|cap-extrdt-auth|cap-info|cap-inst-auth|cap-load-auth|cap-reg-update|cap-sign|card|change-protocol|channel|clear-vars|close|echo|error|exchange-poweroff|exchange-warmreset|exec|expr|glob|identify|l-r|l-v|list-readers|list-vars|manage-channel|mode|printf|r-echo|register|s-v|select|send|set-channel|set-var|sleep|start-timer|stop-timer|term|terminal)(?=\s|\)|#|$)
yaml_variable: &CMD_LIST_BUILTIN
  match: (?<=^|:|\()\s*([@\-])?(>|\?|auth|card-info|delete|delete-key|ext-auth|extradite|flush|get-cplc|get-crs-state|get-data|get-sd-cert|help|init-upd|init-update|install|internal-authenticate|ls|mutual-authenticate|perform-security-operation|personalize|print-key|put-key|put-key-ecc|put-keyset|put-pub-key|quit|registry-update|select|send|session-info|set-applet|set-crs-state|set-key|set-scp|set-sd-state|set-security|set-state|store-aid|store-data|store-keyset|upload|upload-install-make-selectable|version)(?=\s|\)|#|$)
yaml_variable: &CMD_LIST_CRYPTO
  match: (?<=^|:|\()\s*([@\-])?(decrypt|encrypt|hash|keygen|mac|pad|sign|unpad)(?=\s|\)|#|$)
yaml_variable: &CMD_LIST_GP
  match: (?<=^|:|\()\s*([@\-])?(delete|extradite|install|registry-update|upload)(?=\s|\)|#|$)
yaml_variable: &VAR_LIST_BUILTIN
  match: (?<=\{)\s*(?:[Aa]rgv|[Cc]hannel|ECC_CURVEPARAM_A|ECC_CURVEPARAM_B|ECC_CURVEPARAM_G|ECC_CURVEPARAM_N|ECC_CURVEPARAM_P|ECC_SharedSecret|exec\.dir|exec\.errorlog|exec\.output|JCOPDIR|KEY_ECC_PrivateKey|KEY_ECC_PublicKeyX|KEY_ECC_PublicKeyY|KEY_RSA_PrivateKey|KEY_RSA_PrivateKey_dP|KEY_RSA_PrivateKey_dQ|KEY_RSA_PrivateKey_P|KEY_RSA_PrivateKey_PQ|KEY_RSA_PrivateKey_Q|KEY_RSA_PublicKey|last\.apdu\.executiontime|last\.apdu\.executiontime\.unit|last\.error|last\.errorlog|last\.executiontime|last\.executiontime\.unit|last\.response\.data|last\.response\.status|last\.return|logfile\.list|[Pp]ath|[Pp]lugin|random|[Rr]esponse|script\.dir|script\.line|script\.name|scrtimer\.exec\.time|SIGNATURE_ECDSA_R|SIGNATURE_ECDSA_S|SIGNATURE_RSA|timer\.execution\.time|timer\.id|[Tt]erminal|time|VERIFY_SIGN|[Vv]ersion)\s*(?=[\[;\}])
yaml_variable: # Clear the node (variable)

patterns:
- include: '#empty-line'
- include: '#comment'
- include: '#label'
- include: '#line-continuation'
- include: '#comment-line'
- include: '#function-definition'
- include: '#if-block'
- include: '#while-block'
- include: '#for-block'
- include: '#try-block'
- include: '#flow-statement'
- include: '#assignment-operator'
- include: '#assignment-command'
- include: '#continued-line'
- include: '#call'
- include: '#invalid-character'

repository:
  empty-line:
    patterns:
    - comment: Line containing only whitespace
      name: meta.empty.source.jcsh
      match: ^\s*(\\)?$

  comment-line:
    patterns:
    - comment: Line containing only whitespace and a single-line comment starting
        with '#'
      name: meta.comment.line.full.source.jcsh
      match: ^\s*(#)(.*)$
      captures:
        '1': {name: comment.line.number-sign.source.jcsh}
        '2': {name: comment.line.source.jcsh}

  comment:
    patterns:
    - comment: Single-line comment starting with '#'
      name: meta.comment.line.source.jcsh
      match: \s*(?<!\S)(#)(.*)$
      captures:
        '1': {name: comment.line.number-sign.source.jcsh}
        '2': {name: comment.line.source.jcsh}

  invalid-character:
    patterns:
    - comment: Match anything not matched yet
      name: invalid.character.source.jcsh
      match: .

  line-continuation:
    patterns:
    - comment: Line continuation
      name: meta.line-continuation.source.jcsh
      begin: (\\)\s*$
      beginCaptures:
        '1': {name: punctuation.line-continuation.source.jcsh}
      end: $
      patterns:
      - include: '#invalid-character'

  continued-line:
    patterns:
    - comment: Continued line
      name: meta.continued-line.source.jcsh
      begin: ^\s*(?=")
      end: (?=$)
      patterns:
      - begin: \s*(?=")
        end: (?<=\S)(?=\s|\)|$|\\)
        patterns:
        - include: '#string'
        - include: '#invalid-character'

  label:
    patterns:
    - comment: Leading label that can be jumped to using goto. Labels can be placed at the beginning of any line and cannot contain variables
      name: meta.control.label.definition.source.jcsh
      match: ^\s*(\w[\w\-\.]*)\s*(:)
      captures:
        '1': {name: keyword.control.label.definition.source.jcsh}
        '2': {name: punctuation.definition.label.source.jcsh}

  assignment-command:
    patterns:
    - comment: Variable assignment with explicit command, only a label can be placed in front
      name: meta.assignment.source.jcsh
      begin: (?:^|(?<=.:))\s*(/set-var|/s-v)\s((?:\s*(?:-d|--def|-g|--global|-q|--quote)\s)*)
      beginCaptures:
        '1': {name: keyword.assignment.command.source.jcsh}
        '2': {name: variable.parameter.flag.assignment.source.jcsh}
      end: (?=(?:\s#[^\(])|$|\\)
      patterns:
      - comment: Match the newly defined variable name (consume up to the next space). We have to rematch the beginning of the line to make sure we only take the first word after the space (and that the regex is not applied to each word on the line)
        begin: (?<=(?:/set-var\s|/s-v\s|-d\s|--def\s|-g\s|--global\s|-q\s|--quote\s))\s*
        end: (?<=\S)\s+(?=.*|(?:\s#[^\(])|$|\\)
        patterns:
        - comment: Handle the subscript first (array '[]')
          include: '#subscript'
        - comment: Then the newly defined variable name
          include: '#assignment-name'
      - comment: Process the value assigned (after the first space)
        include: '#expression'
      - comment: Spaces are legit for variable assignment
        match: \s
      - include: '#invalid-character'

  assignment-operator:
    patterns:
    - comment: "Variable assignment with operator ('='). Avoid assignment detection if the following operators are formed with the '=': <= >= == != =~ or if part of a modifier (';xxx='). Only a label can be placed in front"
      name: meta.assignment.source.jcsh
      begin: (?:^|(?<=.:))\s*(?=.*[^<>\=\!]\=[^~\=])(?!.*;\w\w\w\=)
      end: (?<=.)\s*(?=(?:\s#[^\(])|$|\\)
      patterns:
      - comment: Match the newly defined variable name (consume up to the '=')
        begin: (?<=(?:.|^))(?=.*\=)
        end: (=)(?=.|(?:\s#[^\(])|$|\\)
        endCaptures:
          '1': {name: keyword.assignment.operator.source.jcsh}
        patterns:
        - comment: Handle the subscript first (array '[]')
          include: '#subscript'
        - comment: Then the newly defined variable name
          include: '#assignment-name'
      - comment: Process the value assigned (after the '=')
        include: '#expression'
      - comment: Spaces are legit for variable assignment
        match: \s
      - include: '#invalid-character'

  assignment-name:
    patterns:
    - comment: Name of the variable newly created (that can contains variables calls inside)
      patterns:
      - include: '#variable'
      - include: '#nested-call'
      - match: \S
        name: variable.assigned.source.jcsh
      - include: '#invalid-character'

  variable:
    patterns:
    - comment: Bracket-style variable reference
      name: meta.reference.variable.source.jcsh
      begin: (\$)(\{)
      beginCaptures:
        '1': {name: punctuation.definition.reference.variable.head.source.jcsh}
        '2': {name: punctuation.definition.reference.variable.begin.source.jcsh}
      end: \}
      endCaptures:
        '0': {name: punctuation.definition.reference.variable.end.source.jcsh}
      patterns:
      - include: '#subscript'
      - include: '#plugin-modifier'
      - include: '#modifier'
      - include: '#variable-name'
      - include: '#invalid-character'

  subscript:
    patterns:
    - comment: Variable subscript (array '[]')
      begin: (\[)
      beginCaptures:
        '1': {name: punctuation.definition.subscript.begin.source.jcsh}
      end: (\])
      endCaptures:
        '1': {name: punctuation.definition.subscript.end.source.jcsh}
      patterns:
      - comment: Inside the '[]' (no space allowed)
      - comment: Match '[*]' to color the '*'
        match: (?<=\[)\*(?=\])
        name: punctuation.subscript.content.asterisk.source.jcsh
      - include: '#expression'
      - comment: Match '[#]' to color the '#', only if it's not part of a variable call
        match: (?<=\[)\#(?=\](?:\s|=))
        name: punctuation.subscript.content.number-sign.source.jcsh
      - include: '#invalid-character'

  variable-name:
    patterns:
    - comment: Variable name. May contain replaced variables and interpolations
      name: meta.variable.name.source.jcsh
      begin: (?<=\{)
      end: (?=[:\[;\}])
      patterns:
      - include: '#variable-name-builtin'
      - include: '#variable-name-positional'
      - include: '#variable-name-environment'
      - include: '#variable-name-user'
      - include: '#invalid-character'

  variable-name-builtin:
    patterns:
    - comment: Name of a JCShell built-in variable.
      name: support.variable.name.builtin.source.jcsh
      <<: *VAR_LIST_BUILTIN

  variable-name-positional:
    patterns:
    - comment: Name of a positional variable
      name: support.variable.name.positional.source.jcsh
      match: (?<=\{)\d+(?=[\[;\}])

  variable-name-environment:
    patterns:
    - comment: Name of an environment variable (starting with '*')
      name: meta.variable.name.environment.source.jcsh
      match: (?<=\{)(\*)([\w.]+)(?=[\[;\}])
      captures:
        '1': {name: punctuation.definition.variable.name.environment.source.jcsh}
        '2': {name: variable.name.environment.source.jcsh}

  variable-name-user:
    patterns:
    - comment: User-defined variable name
      name: meta.variable.name.user.source.jcsh
      begin: (?<=\{)
      end: (?=[:\[;\}])
      patterns:
      - include: '#variable'
      - include: '#nested-call'
      - match: \S
        name: variable.name.user.source.jcsh
      - include: '#invalid-character'

  modifier:
    patterns:
    - comment: Variable modifier (no space allowed)
      name: meta.variable.modifier.source.jcsh
      begin: ;
      beginCaptures:
        '0': {name: punctuation.separator.variable.modifier.source.jcsh}
      end: (?=[;\}])
      patterns:
      - include: '#builtin-modifier'
      - include: '#variable'
      - include: '#nested-call'
      - include: '#invalid-character'

  builtin-modifier:
    patterns:
    - comment: Built-in variable modifier name (no space allowed)
      name: meta.modifier.name.builtin.source.jcsh
      match: (?<=;)([Dd]irname|[Ff]ilename|[Bb]asename|[Ee]xtension|[Ll]|[Qq]|[Qq]q|[Ll]c|[Uu]c)(?=[;\}])
      captures:
        '0': {name: keyword.modifier.builtin.source.jcsh}
    - comment: Built-in hex variable modifier ('h')
      begin: (?<=;)(h)
      beginCaptures:
        '1': {name: keyword.modifier.builtin.source.jcsh}
      end: \s*(?=[;\}])
      patterns:
      - include: '#variable'
      - include: '#nested-call'
      - name: constant.numeric.decimal.hex-modifier.surrounding.source.jcsh
        match: \d*
      - include: '#invalid-character'
    - comment: Built-in substring variable modifier ('s')
      begin: (?<=;)(s)
      beginCaptures:
        '1': {name: keyword.modifier.builtin.source.jcsh}
      end: (?=[;\}])
      patterns:
      - comment: First argument of substring variable modifier
        begin: (?<=s)
        end: (?=[,;\}])
        patterns:
        - include: '#variable'
        - include: '#nested-call'
        - name: constant.numeric.decimal.substring-modifier.offset.surrounding.source.jcsh
          match: \d*
        - include: '#invalid-character'
      - comment: Second argument of substring variable modifier
        begin: (,)
        beginCaptures:
          '1': {name: punctuation.separator.variable.modifier}
        end: (?=[;\}])
        patterns:
        - include: '#variable'
        - include: '#nested-call'
        - name: constant.numeric.decimal.substring-modifier.length.surrounding.source.jcsh
          match: \d*
        - include: '#invalid-character'
      - include: '#invalid-character'
    - comment: Built-in assigned variable modifier for Time ('time')
      begin: (?<={time;)(fmt)(\=)
      beginCaptures:
        '1': {name: keyword.modifier.builtin.source.jcsh}
        '2': {name: keyword.assignment.operator.source.jcsh}
      end: \s*(?=[;\}])
      patterns:
      - include: '#string'
      - include: '#variable'
      - include: '#nested-call'
      - name: string.unquoted.assigned-modifier.surrounding.source.jcsh
        match: .
      - include: '#invalid-character'
    - comment: Built-in assigned variable modifier for Random ('random')
      begin: (?<={random;)(max|len)(\=)
      beginCaptures:
        '1': {name: keyword.modifier.builtin.source.jcsh}
        '2': {name: keyword.assignment.operator.source.jcsh}
      end: (?=[;\}])
      patterns:
      - include: '#variable'
      - include: '#nested-call'
      - name: constant.numeric.decimal.hex-modifier.surrounding.source.jcsh
        match: \d*
      - include: '#invalid-character'

  plugin-modifier:
    patterns:
    - comment: Modifier for accessing plugin variables
      name: meta.variable.plugin-modifier.source.jcsh
      begin: ':'
      beginCaptures:
        '0': {name: punctuation.separator.variable.modifier.plugin.source.jcsh}
      end: (?=[\[;\}])
      patterns:
      - include: '#variable'
      - include: '#nested-call'
      - name: support.variable.name.plugin.surrounding.source.jcsh
        match: \s*\w[\w\-\.]*\s*
      - include: '#invalid-character'

  call:
    patterns:
    - comment: Call to a built-in command, function or external script. Only a label can be placed in front
      name: meta.control.call.source.jcsh
      begin: (?:^|(?<=.:))
      end: (?<=.)\s*(?=\)|#[^//(]|$|\\)
      patterns:
      - include: '#callable'
      - include: '#argument'
      - match: \s
      - include: '#invalid-character'

  callable:
    patterns:
    - comment: Callable built-in command, function or external script
      name: meta.callable.source.jcsh
      begin: (?<=^|:|\()
      end: (?<=[\w\}\)\?>])(?=\s|\)|#|$)
      patterns:
      - comment: JCShell Crypto Plugin command
        name: meta.support.function.plugin.crypto.source.jcsh
        <<: *CMD_LIST_CRYPTO
        captures:
          '1': {name: punctuation.call-modifier.builtin.source.jcsh}
          '2': {name: support.function.plugin.crypto.source.jcsh}
      - comment: JCShell Provider Security Domain Plugin command
        name: meta.support.function.plugin.psd.source.jcsh
        <<: *CMD_LIST_GP
        captures:
          '1': {name: punctuation.call-modifier.builtin.source.jcsh}
          '2': {name: support.function.plugin.psd.source.jcsh}
      - comment: JCShell built-in slash command
        name: meta.support.function.builtin.slash.source.jcsh
        <<: *CMD_LIST_SLASH_BUILTIN
        captures:
          '1': {name: punctuation.definition.callable.builtin.slash.source.jcsh}
          '2': {name: punctuation.call-modifier.builtin.source.jcsh}
          '3': {name: support.function.builtin.slash.source.jcsh}
      - comment: JCShell built-in command
        name: meta.support.function.builtin.source.jcsh
        <<: *CMD_LIST_BUILTIN
        captures:
          '1': {name: punctuation.call-modifier.builtin.source.jcsh}
          '2': {name: support.function.builtin.source.jcsh}
      - comment: User-defined callable
        name: meta.callable.user.source.jcsh
        begin: (?<=^|:|\()
        end: (?<=[\}\)\w])(?=\s|\)|#|$)
        patterns:
        - match: (?<=^|:|\()\s*([@\-])?
          captures:
            '1': {name: punctuation.call-modifier.user.source.jcsh}
        - include: '#variable'
        - include: '#nested-call'
        - match: (\S)
          captures:
            '1': {name: entity.name.function.surrounding.source.jcsh}
        - include: '#invalid-character'
      - include: '#invalid-character'

  argument:
    patterns:
    - comment: Argument of a call
      name: meta.argument.source.jcsh
      begin: (?<=\s)\s*
      end: (?<=\S)(?=\s|\)|$|\\)
      patterns:
      - include: '#flag'
      - include: '#expression'
      - include: '#invalid-character'

  flag:
    patterns:
    - comment: Flag argument of a call
      name: meta.flag.source.jcsh
      begin: (?<=\s)(--?)(?=\w)
      beginCaptures:
        '1': {name: punctuation.definition.flag.source.jcsh}
      end: (?<=[\}\)\w])(?=\)|\s|#|$)
      patterns:
      - include: '#variable'
      - include: '#nested-call'
      - name: variable.parameter.flag.surrounding.source.jcsh
        match: \w[\w\-\.]*
      - include: '#invalid-character'

  expression:
    patterns:
    - include: '#string'
    - include: '#variable'
    - include: '#nested-call'
    - include: '#number'
    - include: '#operator'
    - name: string.unquoted.expression.surrounding.source.jcsh
      match: '[\w\-\.,\=!:;]+'
    - begin: (#)?(\()
      beginCaptures:
        '1': {name: punctuation.parentheses.modifier.source.jcsh}
        '2': {name: punctuation.parentheses.begin.source.jcsh}
      end: \)
      endCaptures:
        '0': {name: punctuation.parentheses.end.source.jcsh}
      patterns:
      - include: '#expression'

  nested-call:
    patterns:
    - comment: Nested call ('$()')
      name: meta.nested-call.source.jcsh
      begin: (\$)(\()
      beginCaptures:
        '1': {name: punctuation.definition.nested-call.head.source.jcsh}
        '2': {name: punctuation.definition.nested-call.begin.source.jcsh}
      end: \)
      endCaptures:
        '0': {name: punctuation.definition.nested-call.end.source.jcsh}
      patterns:
      - name: meta.nested-call.content.source.jcsh
        begin: (?<=\()
        end: (?<=.)\s*(?=\)|#[^\(]|$|(\\))
        patterns:
        - include: '#callable'
        - include: '#argument'
        - match: \s
        - include: '#invalid-character'
      - include: '#invalid-character'

  number:
    patterns:
    - name: constant.numeric.hexadecimal.source.jcsh
      match: (?<!\w)(0x)[\da-fA-F]+(?![\w.])
    - name: constant.numeric.decimal.source.jcsh
      match: (?<!\w)\d+(?![\w.])

  string:
    patterns:
    - comment: Single-quoted string literal without variable replacement and interpolation
      name: meta.string.source.jcsh
      begin: "'"
      beginCaptures:
        '0': {name: punctuation.definition.string.single.begin.source.jcsh}
      end: "'"
      endCaptures:
        '0': {name: punctuation.definition.string.single.end.source.jcsh}
      patterns:
      - name: constant.character.escape.source.jcsh
        match: \\['\\]
      - name: string.quoted.single.surrounding.source.jcsh
        match: .
    - comment: Double-quoted string literal with variable replacement and interpolation
      name: meta.string.source.jcsh
      begin: '"'
      beginCaptures:
        '0': {name: punctuation.definition.string.double.begin.source.jcsh}
      end: '"'
      endCaptures:
        '0': {name: punctuation.definition.string.double.end.source.jcsh}
      patterns:
      - include: '#variable'
      - include: '#nested-call'
      - name: constant.character.escape.source.jcsh
        match: \\[\$"\\]
      - name: string.quoted.double.surrounding.source.jcsh
        match: .

  operator:
    patterns:
    - name: keyword.operator.source.jcsh
      match: -|\*|/|%|\+|<<|>>>|>>|<=|<|>=|>|==|!=|!|=~|~|&|\^|\||\.\.|\?

  if-block:
    patterns:
    - comment: If block, only a label can be placed in front
      name: meta.control.if.source.jcsh
      begin: (?:^|(?<=.:))\s*(if)(?=\s+\S+.*$|(\\))
      beginCaptures:
        '1': {name: keyword.control.if.source.jcsh}
      end: ^\s*(end)\s*(?:\s(#)(.*))?$
      endCaptures:
        '1': {name: keyword.control.if.end.source.jcsh}
        '2': {name: comment.line.number-sign.source.jcsh}
        '3': {name: comment.line.source.jcsh}
      patterns:
      - include: '#flow-expression'
      - include: '#elseif-clause'
      - include: '#else-clause'
      - include: $self

  flow-expression:
    patterns:
    - comment: "Expression check for flow control blocks: if, for, while, elseif, catch, return"
      begin: (?<=for|if|elseif|while|catch|return)\s+
      end: \s*(?:\s(#)(.*))?$|(\\)
      endCaptures:
        '1': {name: comment.line.number-sign.source.jcsh}
        '2': {name: comment.line.source.jcsh}
      patterns:
      - comment: The 'for' block as an additional iterator provided
        match: (?<=for\s)\s*(\w[\w\-\.]*)
        name: variable.parameter.iterator.source.jcsh
      - include: '#expression'
      - match: \s
      - include: '#invalid-character'

  else-clause:
    patterns:
    - comment: Else clause
      name: meta.control.else.source.jcsh
      match: ^\s*(else)\s*(?:\s(#)(.*))?$|(\\)
      captures:
        '1': {name: keyword.control.else.source.jcsh}
        '2': {name: comment.line.number-sign.source.jcsh}
        '3': {name: comment.line.source.jcsh}

  elseif-clause:
    patterns:
    - comment: Elseif clause
      name: meta.control.elseif.jcsh
      begin: ^\s*(elseif)
      beginCaptures:
        '1': {name: keyword.control.elseif.jcsh}
      end: \s*(?:\s#.*)?$|\\
      patterns:
      - include: '#flow-expression'

  try-block:
    patterns:
    - comment: Try block, only a label can be placed in front
      name: meta.control.try.source.jcsh
      begin: (?:^|(?<=.:))\s*(try)\s*(?:\s(#)(.*))?$|(\\)
      beginCaptures:
        '1': {name: keyword.control.try.source.jcsh}
        '2': {name: comment.line.number-sign.source.jcsh}
        '3': {name: comment.line.source.jcsh}
      end: ^\s*(end)\s*(?:\s(#)(.*))?$
      endCaptures:
        '1': {name: keyword.control.try.end.source.jcsh}
        '2': {name: comment.line.number-sign.source.jcsh}
        '3': {name: comment.line.source.jcsh}
      patterns:
      - include: '#catch-clause'
      - include: $self

  catch-clause:
    comment: Catch clause
    name: meta.control.catch.source.jcsh
    begin: ^\s*(catch)
    beginCaptures:
      '1': {name: keyword.control.catch.source.jcsh}
    end: \s*(?:\s#.*)?$|\\
    patterns:
    - include: '#flow-expression'

  for-block:
    patterns:
    - comment: For block, only a label can be placed in front
      name: meta.control.for.source.jcsh
      begin: (?:^|(?<=.:))\s*(for)(?=\s+\S+.*$|(\\))
      beginCaptures:
        '1': {name: keyword.control.for.source.jcsh}
      end: ^\s*(end)\s*(?:\s(#)(.*))?$
      endCaptures:
        '1': {name: keyword.control.for.end.source.jcsh}
        '2': {name: comment.line.number-sign.source.jcsh}
        '3': {name: comment.line.source.jcsh}
      patterns:
      - include: '#flow-expression'
      - include: '#flow-statement'
      - include: $self

  flow-statement:
    patterns:
    - comment: Break, continue or goto statement, only a label can be placed in front. Goto requires a label after. This is check before callable, thus we enforce keywords continue, goto and break to not be used as function/script name even though JCShell is not actively forbidding it (outside loops)
      name: meta.control.flow.source.jcsh
      match: (?:^|(?<=.:))\s*(?:(break)|(continue)|(?:(goto)(?=\s+\S)))(?:\s*(\w[\w\-\.]*))?\s*(?:\s(#)(.*))?$|(\\)
      captures:
        '1': {name: keyword.control.break.source.jcsh}
        '2': {name: keyword.control.continue.source.jcsh}
        '3': {name: keyword.control.goto.source.jcsh}
        '4': {name: keyword.control.label.target.source.jcsh}
        '5': {name: comment.line.number-sign.source.jcsh}
        '6': {name: comment.line.source.jcsh}

  while-block:
    patterns:
    - comment: While block, only a label can be placed in front
      name: meta.control.while.source.jcsh
      begin: (?:^|(?<=.:))\s*(while)(?=\s+\S+.*$|(\\))
      beginCaptures:
        '1': {name: keyword.control.while.source.jcsh}
      end: ^\s*(end)\s*(?:\s(#)(.*))?$
      endCaptures:
        '1': {name: keyword.control.while.end.source.jcsh}
        '2': {name: comment.line.number-sign.source.jcsh}
        '3': {name: comment.line.source.jcsh}
      patterns:
      - include: '#flow-expression'
      - include: '#flow-statement'
      - include: $self

  function-definition:
    patterns:
    - comment: DEFUN function definition. 'GLOBAL' is the only value allowed after function name (with comments)
      name: meta.section.function-definition.source.jcsh
      begin: ^\s*(DEFUN)\s+(\S*)\s*(GLOBAL)?\s*(?=\s|\)|#|$)
      beginCaptures:
        '1': {name: keyword.function.definition.begin.source.jcsh}
        '2': {name: entity.name.function.definition.source.jcsh}
        '3': {name: variable.parameter.definition.source.jcsh}
      end: ^\s*(END)\s*(?:\s(#)(.*))?$
      endCaptures:
        '1': {name: keyword.function.definition.begin.source.jcsh}
        '2': {name: comment.line.number-sign.source.jcsh}
        '3': {name: comment.line.source.jcsh}
      patterns:
      - include: '#return-statement'
      - include: $self

  return-statement:
    patterns:
    - comment: Return statement, only a label can be placed in front
      name: meta.control.return.source.jcsh
      begin: (?:^|(?<=.:))\s*(return)
      beginCaptures:
        '1': {name: keyword.control.return.source.jcsh}
      end: \s*(?:\s#.*)?$|\\
      patterns:
      - include: '#flow-expression'

...
