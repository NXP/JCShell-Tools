# [PackageDev] target_format: plist, ext: tmLanguage
---

name: JCShell Tools
scopeName: source.jcsh
fileTypes: [jcsh]
uuid: 18d303a3-9fdd-4503-8eba-e8c0b283ddc1

# Define here variables to be re-used in the file for ease of modification
yaml_variable: &CMD_LIST_SLASH_BUILTIN
  match: (?<=^|:|\()\s*(?:(/)|([@\-]))(app|applet|atr|c-v|cap-clear|cap-del-auth|cap-extrdt-auth|cap-info|cap-inst-auth|cap-load-auth|cap-reg-update|cap-sign|card|change-protocol|channel|clear-vars|close|echo|error|exchange-poweroff|exchange-warmreset|exec|expr|glob|identify|l-r|l-v|list-readers|list-vars|manage-channel|mode|printf|r-echo|register|s-v|select|send|set-channel|set-var|sleep|start-timer|stop-timer|term|terminal)(?=\s|\)|#|$)
yaml_variable: &CMD_LIST_BUILTIN
  match: (?<=^|:|\()\s*([@\-])?(>|\?|auth|card-info|delete|delete-key|ext-auth|extradite|flush|get-cplc|get-crs-state|get-data|get-sd-cert|help|init-upd|init-update|install|internal-authenticate|ls|mutual-authenticate|perform-security-operation|personalize|print-key|put-key|put-key-ecc|put-keyset|put-pub-key|quit|registry-update|select|send|session-info|set-applet|set-crs-state|set-key|set-scp|set-sd-state|set-security|set-state|store-aid|store-data|store-keyset|upload|upload-install-make-selectable|version)(?=\s|\)|#|$)
yaml_variable: &CMD_LIST_CRYPTO
  match: (?<=^|:|\()\s*([@\-])?(decrypt|encrypt|hash|keygen|mac|pad|sign|unpad)(?=\s|\)|#|$)
yaml_variable: &CMD_LIST_GP
  match: (?<=^|:|\()\s*([@\-])?(delete|extradite|install|registry-update|upload)(?=\s|\)|#|$)
yaml_variable: &VAR_LIST_BUILTIN
  match: (?<=\{)\s*(?:[Aa]rgv|[Cc]hannel|ECC_CURVEPARAM_A|ECC_CURVEPARAM_B|ECC_CURVEPARAM_G|ECC_CURVEPARAM_N|ECC_CURVEPARAM_P|ECC_SharedSecret|exec\.dir|exec\.errorlog|exec\.output|JCOPDIR|KEY_ECC_PrivateKey|KEY_ECC_PublicKeyX|KEY_ECC_PublicKeyY|KEY_RSA_PrivateKey|KEY_RSA_PrivateKey_dP|KEY_RSA_PrivateKey_dQ|KEY_RSA_PrivateKey_P|KEY_RSA_PrivateKey_PQ|KEY_RSA_PrivateKey_Q|KEY_RSA_PublicKey|last\.apdu\.executiontime|last\.apdu\.executiontime\.unit|last\.error|last\.errorlog|last\.executiontime|last\.executiontime\.unit|last\.response\.data|last\.response\.status|last\.return|logfile\.list|[Pp]ath|[Pp]lugin|[Rr]andom|[Rr]esponse|script\.dir|script\.line|script\.name|scrtimer\.exec\.time|SIGNATURE_ECDSA_R|SIGNATURE_ECDSA_S|SIGNATURE_RSA|timer\.execution\.time|timer\.id|[Tt]erminal|[Tt]ime|VERIFY_SIGN|[Vv]ersion)\s*(?=[\[;\}])
yaml_variable: # Clear the node

patterns:
- include: '#line-continuation'
- include: '#comment'
- include: '#comment-line'
- include: '#empty-line'
- include: '#function-definition'
- include: '#if-block'
- include: '#while-block'
- include: '#for-block'
- include: '#try-block'
- include: '#goto-statement'
- include: '#assignment-operator'
- include: '#assignment-operator-with-subscript'
- include: '#assignment-command'
- include: '#assignment-command-with-subscript'
- include: '#continued-line'
- include: '#call'
- include: '#invalid-character'

repository:
  comment:
    patterns:
    - comment: Single-line comment starting with '#'
      name: meta.comment.line.source.jcsh
      match: \s*(?<!\S)(#)(.*)$
      captures:
        '1': {name: comment.line.number-sign.source.jcsh}
        '2': {name: comment.line.source.jcsh}

  argument:
    patterns:
    - comment: Argument of a call
      name: meta.argument.source.jcsh
      begin: (?<=\s)\s*
      end: (?<=\S)(?=\s|\)|$|\\)
      patterns:
      - include: '#flag'
      - include: '#expression'
      - include: '#invalid-character'

  assignment-command:
    patterns:
    - comment: Variable assignment with command and no subscript
      name: meta.assignment.source.jcsh
      begin: ^(?:\s*(\w[\w\-\.]*)\s*(:))?\s*(/set-var|/s-v)\s+((?:(?:-d|--def|-g|--global|-q|--quote)\s+)*)(\w[\w\-\.]*)\s*(?=(\s[^\[])|$|\\)
      beginCaptures:
        '1': {name: keyword.control.label.definition.source.jcsh}
        '2': {name: punctuation.definition.label.source.jcsh}
        '3': {name: keyword.assignment.command.source.jcsh}
        '4': {name: variable.parameter.flag.assignment.source.jcsh}
        '5': {name: variable.assigned.source.jcsh}
      end: \s*(?=(\s#[^\(])|$|\\)
      patterns:
      - include: '#expression'
      - match: \s
      - include: '#invalid-character'

  assignment-command-subscript:
    patterns:
    - comment: Subscript in assignment command
      name: meta.assignment.susbcript.source.jcsh
      begin: (\[)
      beginCaptures:
        '1': {name: punctuation.definition.subscript.begin.source.jcsh}
      end: (\])\s*
      endCaptures:
        '1': {name: punctuation.definition.subscript.end.source.jcsh}
      patterns:
      - name: punctuation.subscript.content.asterisk.source.jcsh
        match: \s*\*\s*
      - include: '#expression'
      - name: punctuation.subscript.content.number-sign.source.jcsh
        match: \s*#\s*
      - match: \s
      - include: '#invalid-character'

  assignment-command-subscript-target:
    patterns:
    - comment: Variable that is assigned a value with a subscript
      name: meta.assignment.target.jcsh
      begin: (?<=/set-var\s|/s-v\s)
      end: (?<=[\w\}\)])(?=\s*\[)
      patterns:
      - comment: Name of an assigned variable
        name: meta.variable.assigned.source.jcsh
        begin: (?<=/set-var\s|/s-v\s)\s*((?:(?:-d|--def|-g|--global|-q|--quote)\s+)*)
        beginCaptures:
          '1': {name: variable.parameter.flag.assignment.source.jcsh}
        end: \s*(?=\[)
        patterns:
        - include: '#variable'
        - include: '#nested-call'
        - name: variable.assigned.surrounding.source.jcsh
          match: \w[\w\-\.]*
        - include: '#invalid-character'

  assignment-command-with-subscript:
    patterns:
    - comment: Variable assignment with command and subscript
      name: meta.assignment.source.jcsh
      begin: ^(?:\s*(\w[\w\-\.]*)\s*(:))?\s*(/set-var|/s-v)\s
      beginCaptures:
        '1': {name: keyword.control.label.definition.source.jcsh}
        '2': {name: punctuation.definition.label.source.jcsh}
        '3': {name: keyword.assignment.command.source.jcsh}
      end: \s*(?=(\s#[^\(])|$|\\)
      patterns:
      - include: '#assignment-command-subscript-target'
      - include: '#assignment-command-subscript'
      - include: '#expression'
      - match: \s
      - include: '#invalid-character'

  assignment-operator:
    patterns:
    - comment: Variable assignment with operator and no subscript
      name: meta.assignment.source.jcsh
      begin: ^(?:\s*(\w[\w\-\.]*)\s*(:))?\s*(@)?(\w[\w\-\.]*)\s*(\=)
      beginCaptures:
        '1': {name: keyword.control.label.definition.source.jcsh}
        '2': {name: punctuation.definition.label.source.jcsh}
        '3': {name: punctuation.call-modifier.builtin.source.jcsh}
        '4': {name: variable.assigned.source.jcsh}
        '5': {name: keyword.operator.assignment.source.jcsh}
      end: (?<=.)\s*(?=(\s#[^\(])|$|\\)
      patterns:
      - include: '#expression'
      - match: \s
      - include: '#invalid-character'

  assignment-operator-subscript:
    patterns:
    - comment: Subscript in assignment operation
      name: meta.assignment.subscript.source.jcsh
      begin: (\[)
      beginCaptures:
        '1': {name: punctuation.definition.subscript.begin.source.jcsh}
      end: (\])\s*(\=)
      endCaptures:
        '1': {name: punctuation.definition.subscript.end.source.jcsh}
        '2': {name: keyword.operator.assignment.source.jcsh}
      patterns:
      - match: \s*\*\s*
        name: punctuation.subscript.content.asterisk.source.jcsh
      - include: '#expression'
      - match: \s*#\s*
        name: punctuation.subscript.content.number-sign.source.jcsh
      - match: \s
      - include: '#invalid-character'

  assignment-operator-subscript-target:
    patterns:
    - comment: Variable that is assigned a value with a subscript
      name: meta.assignment.target.source.jcsh
      begin: (?<=^|:)
      end: (?=\s*\[.*\]\s*\=)
      patterns:
      - comment: Name of an assigned variable
        name: meta.variable.assigned.source.jcsh
        begin: (?<=^|:)\s*(@)?
        beginCaptures:
          '1': {name: punctuation.call-modifier.builtin.source.jcsh}
        end: \s*(?=\[.*\]\s*\=)
        patterns:
        - include: '#variable'
        - include: '#nested-call'
        - match: \w[\w\-\.]*
          name: variable.assigned.surrounding.source.jcsh
        - include: '#invalid-character'

  assignment-operator-with-subscript:
    patterns:
    - comment: Variable assignment with operator and subscript
      name: meta.assignment.source.jcsh
      begin: '^(?:\s*(\w[\w\-\.]*)\s*(:))?(?=(?:.(?!= #))*\]\s*\=.*$)'
      beginCaptures:
        '1': {name: keyword.control.label.definition.source.jcsh}
        '2': {name: punctuation.definition.label.source.jcsh}
      end: (?<=.)\s*(?=(\s#[^\(])|$|\\)
      patterns:
      - include: '#assignment-operator-subscript-target'
      - include: '#assignment-operator-subscript'
      - include: '#expression'
      - match: \s
      - include: '#invalid-character'

  break-statement:
    patterns:
    - comment: Break statement
      name: meta.control.break.source.jcsh
      match: ^(?:\s*(\w[\w\-\.]*)\s*(:))?\s*(break)(?:\s+(\w[\w\-\.]*))?\s*(?:\s(#)(.*))?$|(\\)
      captures:
        '1': {name: keyword.control.label.definition.source.jcsh}
        '2': {name: punctuation.definition.label.source.jcsh}
        '3': {name: keyword.control.break.source.jcsh}
        '4': {name: keyword.control.label.target.source.jcsh}
        '5': {name: comment.line.number-sign.source.jcsh}
        '6': {name: comment.line.source.jcsh}

  builtin-modifier:
    patterns:
    - comment: Built-in variable modifier name
      name: meta.modifier.name.builtin.source.jcsh
      match: (?<=;)\s*([Dd]irname|[Ff]ilename|[Bb]asename|[Ee]xtension|[Ll]|[Qq]|[Qq]q|[Ll]c|[Uu]c)\s*(?=[;\}])
      captures:
        '0': {name: keyword.modifier.builtin.source.jcsh}
    - comment: Built-in hex variable modifier
      begin: (?<=;)\s*(h)\s*
      beginCaptures:
        '1': {name: keyword.modifier.builtin.source.jcsh}
      end: \s*(?=[;\}])
      patterns:
      - include: '#variable'
      - include: '#nested-call'
      - name: constant.numeric.decimal.hex-modifier.surrounding.source.jcsh
        match: \d*
      - include: '#invalid-character'
    - comment: Built-in substring variable modifier
      begin: (?<=;)\s*(s)
      beginCaptures:
        '1': {name: keyword.modifier.builtin.source.jcsh}
      end: \s*(?=[;\}])
      patterns:
      - comment: First argument of substring variable modifier
        begin: (?<=s)\s*
        end: \s*(?=[,;\}])
        patterns:
        - include: '#variable'
        - include: '#nested-call'
        - name: constant.numeric.decimal.substring-modifier.offset.surrounding.source.jcsh
          match: \d*
        - include: '#invalid-character'
      - comment: Second argument of substring variable modifier
        begin: (,)\s*
        beginCaptures:
          '1': {name: punctuation.separator.variable.modifier}
        end: \s*(?=[;\}])
        patterns:
        - include: '#variable'
        - include: '#nested-call'
        - name: constant.numeric.decimal.substring-modifier.length.surrounding.source.jcsh
          match: \d*
        - include: '#invalid-character'
      - include: '#invalid-character'
    - comment: Built-in assigned variable modifier
      begin: (?<=;)\s*(fmt|len)\s*(\=)
      beginCaptures:
        '1': {name: keyword.modifier.builtin.source.jcsh}
        '2': {name: keyword.operator.assignment.source.jcsh}
      end: \s*(?=[;\}])
      patterns:
      - include: '#variable'
      - name: string.unquoted.assigned-modifier.surrounding.source.jcsh
        match: .
      - include: '#invalid-character'

  builtin-variable-name:
    patterns:
    - comment: Name of a JCShell built-in variable.
      name: support.variable.name.builtin.source.jcsh
      <<: *VAR_LIST_BUILTIN

  call:
    patterns:
    - comment: Call to a built-in command, function or external script
      name: meta.control.call.source.jcsh
      begin: ^
      end: (?<=.)\s*(?=\)|#[^//(]|$|\\)
      patterns:
      - include: '#label'
      - include: '#callable'
      - include: '#argument'
      - match: \s
      - include: '#invalid-character'

  callable:
    patterns:
    - comment: Callable built-in command, function or external script
      name: meta.callable.source.jcsh
      begin: (?<=^|:|\()
      end: (?<=[\w\}\)\?>])(?=\s|\)|#|$)
      patterns:
      - comment: JCShell Crypto Plugin command
        name: meta.support.function.plugin.crypto.source.jcsh
        <<: *CMD_LIST_CRYPTO
        captures:
          '1': {name: punctuation.call-modifier.builtin.source.jcsh}
          '2': {name: support.function.plugin.crypto.source.jcsh}
      - comment: JCShell Provider Security Domain Plugin command
        name: meta.support.function.plugin.psd.source.jcsh
        <<: *CMD_LIST_GP
        captures:
          '1': {name: punctuation.call-modifier.builtin.source.jcsh}
          '2': {name: support.function.plugin.psd.source.jcsh}
      - comment: JCShell built-in slash command
        name: meta.support.function.builtin.slash.source.jcsh
        <<: *CMD_LIST_SLASH_BUILTIN
        captures:
          '1': {name: punctuation.definition.callable.builtin.slash.source.jcsh}
          '2': {name: punctuation.call-modifier.builtin.source.jcsh}
          '3': {name: support.function.builtin.slash.source.jcsh}
      - comment: JCShell built-in command
        name: meta.support.function.builtin.source.jcsh
        <<: *CMD_LIST_BUILTIN
        captures:
          '1': {name: punctuation.call-modifier.builtin.source.jcsh}
          '2': {name: support.function.builtin.source.jcsh}
      - comment: User-defined callable
        name: meta.callable.user.source.jcsh
        begin: (?<=^|:|\()
        end: (?<=[\}\)\w])(?=\s|#|\)|$)
        patterns:
        - match: (?<=^|:|\()\s*([@\-])?
          captures:
            '1': {name: punctuation.call-modifier.user.source.jcsh}
        - include: '#variable'
        - include: '#nested-call'
        - match: ([\w\/][\w\-\/\.\\]*)
          captures:
            '1': {name: entity.name.function.surrounding.source.jcsh}
        - include: '#invalid-character'
      - include: '#invalid-character'

  catch-clause:
    comment: Catch clause
    name: meta.control.catch.source.jcsh
    begin: ^\s*(catch)\s+
    beginCaptures:
      '1': {name: keyword.control.catch.source.jcsh}
    end: \s*(?:\s(#)(.*))?$|(\\)
    endCaptures:
      '1': {name: comment.line.number-sign.source.jcsh}
      '2': {name: comment.line.source.jcsh}
    patterns:
    - include: '#expression'
    - match: \s
    - include: '#invalid-character'

  comment-line:
    patterns:
    - comment: Line containing only whitespace and a single-line comment starting
        with '#'
      name: meta.comment.line.full.source.jcsh
      match: ^\s*(#)(.*)$
      captures:
        '1': {name: comment.line.number-sign.source.jcsh}
        '2': {name: comment.line.source.jcsh}

  continue-statement:
    patterns:
    - comment: Continue statement
      name: meta.control.continue.source.jcsh
      match: ^(?:\s*(\w[\w\-\.]*)\s*(:))?\s*(continue)(?:\s+(\w[\w\-\.]*))?\s*(?:\s(#)(.*))?$|(\\)
      captures:
        '1': {name: keyword.control.label.definition.source.jcsh}
        '2': {name: punctuation.definition.label.source.jcsh}
        '3': {name: keyword.control.continue.source.jcsh}
        '4': {name: keyword.control.label.target.source.jcsh}
        '5': {name: comment.line.number-sign.source.jcsh}
        '6': {name: comment.line.source.jcsh}

  continued-line:
    patterns:
    - comment: Continued line
      name: meta.continued-line.source.jcsh
      begin: ^\s*(?=")
      end: (?=$)
      patterns:
      - begin: \s*(?=")
        end: (?<=\S)(?=\s|\)|$|\\)
        patterns:
        - include: '#string'
        - include: '#invalid-character'

  else-clause:
    patterns:
    - comment: Else clause
      name: meta.control.else.source.jcsh
      match: ^\s*(else)\s*(?:\s(#)(.*))?$|(\\)
      captures:
        '1': {name: keyword.control.else.source.jcsh}
        '2': {name: comment.line.number-sign.source.jcsh}
        '3': {name: comment.line.source.jcsh}

  elseif-clause:
    patterns:
    - comment: Elseif clause
      name: meta.control.elseif.jcsh
      begin: ^\s*(elseif)\s+
      beginCaptures:
        '1': {name: keyword.control.elseif.jcsh}
      end: \s*(?:\s(#)(.*))?$|(\\)
      endCaptures:
        '1': {name: comment.line.number-sign.source.jcsh}
        '2': {name: comment.line.source.jcsh}
      patterns:
      - include: '#expression'
      - match: \s
      - include: '#invalid-character'

  empty-line:
    patterns:
    - comment: Line containing only whitespace
      name: meta.empty.source.jcsh
      match: ^\s*(\\)?$

  environment-variable-name:
    patterns:
    - comment: Name of an environment variable.
      name: meta.variable.name.environment.source.jcsh
      match: (?<=\{)\s*(\*)([\w.]+)\s*(?=[\[;\}])
      captures:
        '1': {name: punctuation.definition.variable.name.environment.source.jcsh}
        '2': {name: variable.name.environment.source.jcsh}

  expression:
    patterns:
    - include: '#string'
    - include: '#variable'
    - include: '#nested-call'
    - include: '#number'
    - include: '#operator'
    - name: string.unquoted.expression.surrounding.source.jcsh
      match: '[\w\-\.,\=!:;]+'
    - begin: (#)?(\()
      beginCaptures:
        '1': {name: punctuation.parentheses.modifier.source.jcsh}
        '2': {name: punctuation.parentheses.begin.source.jcsh}
      end: \)
      endCaptures:
        '0': {name: punctuation.parentheses.end.source.jcsh}
      patterns:
      - include: '#expression'

  flag:
    patterns:
    - comment: Flag argument of a call
      name: meta.flag.source.jcsh
      begin: (?<=\s)(--?)(?=\w)
      beginCaptures:
        '1': {name: punctuation.definition.flag.source.jcsh}
      end: (?<=[\}\)\w])(?=\)|\s|#|$)
      patterns:
      - include: '#variable'
      - include: '#nested-call'
      - name: variable.parameter.flag.surrounding.source.jcsh
        match: \w[\w\-\.]*
      - include: '#invalid-character'

  for-block:
    patterns:
    - comment: For block
      name: meta.control.for.source.jcsh
      begin: ^(?:\s*(\w[\w\-\.]*)\s*(:))?\s*(for)(?=\s+\S+.*$|(\\))
      beginCaptures:
        '1': {name: keyword.control.label.definition.source.jcsh}
        '2': {name: punctuation.definition.label.source.jcsh}
        '3': {name: keyword.control.for.source.jcsh}
      end: ^\s*(end)\s*(?:\s(#)(.*))?$
      endCaptures:
        '1': {name: keyword.control.for.end.source.jcsh}
        '2': {name: comment.line.number-sign.source.jcsh}
        '3': {name: comment.line.source.jcsh}
      patterns:
      - include: '#for-expression'
      - include: '#break-statement'
      - include: '#continue-statement'
      - include: $self

  for-expression:
    patterns:
    - begin: (?<=for)\s+(\w[\w\-\.]*)
      beginCaptures:
        '1': {name: variable.parameter.iterator.source.jcsh}
      end: \s*(?:\s(#)(.*))?$
      endCaptures:
        '1': {name: comment.line.number-sign.source.jcsh}
        '2': {name: comment.line.source.jcsh}
      patterns:
      - include: '#expression'
      - match: \s
      - include: '#invalid-character'

  function-definition:
    patterns:
    - comment: DEFUN function definition
      name: meta.section.function-definition.source.jcsh
      begin: ^\s*(DEFUN)\s+(\w[\w\-]*)((?:\s+\w[\w\-\.]*)*)\s*(?:\s(#)(.*))?$|(\\)
      beginCaptures:
        '1': {name: keyword.function.definition.begin.source.jcsh}
        '2': {name: entity.name.function.definition.source.jcsh}
        '3': {name: variable.parameter.definition.source.jcsh}
        '4': {name: comment.line.number-sign.source.jcsh}
        '5': {name: comment.line.source.jcsh}
      end: ^\s*(END)\s*(?:\s(#)(.*))?$
      endCaptures:
        '1': {name: keyword.function.definition.begin.source.jcsh}
        '2': {name: comment.line.number-sign.source.jcsh}
        '3': {name: comment.line.source.jcsh}
      patterns:
      - include: '#return-statement'
      - include: $self

  goto-statement:
    patterns:
    - comment: Goto statement
      name: meta.control.goto.source.jcsh
      match: ^(?:\s*(\w[\w\-\.]*)\s*(:))?\s*(goto)\s+(\w[\w\-\.]*)\s*(?:\s(#)(.*))?$|(\\)
      captures:
        '1': {name: keyword.control.label.definition.source.jcsh}
        '2': {name: punctuation.definition.label.source.jcsh}
        '3': {name: keyword.control.goto.source.jcsh}
        '4': {name: keyword.control.label.target.source.jcsh}
        '5': {name: 'comment.line.number-sign.source.jcsh '}
        '6': {name: comment.line.source.jcsh}

  if-block:
    patterns:
    - comment: If block
      name: meta.control.if.source.jcsh
      begin: ^(?:\s*(\w[\w\-\.]*)\s*(:))?\s*(if)(?=\s+\S+.*$|(\\))
      beginCaptures:
        '1': {name: keyword.control.label.definition.source.jcsh}
        '2': {name: punctuation.definition.label.source.jcsh}
        '3': {name: keyword.control.if.source.jcsh}
      end: ^\s*(end)\s*(?:\s(#)(.*))?$
      endCaptures:
        '1': {name: keyword.control.if.end.source.jcsh}
        '2': {name: comment.line.number-sign.source.jcsh}
        '3': {name: comment.line.source.jcsh}
      patterns:
      - include: '#if-expression'
      - include: '#elseif-clause'
      - include: '#else-clause'
      - include: $self

  if-expression:
    patterns:
    - begin: (?<=if)\s+
      end: \s*(?:\s(#)(.*))?$|(\\)
      endCaptures:
        '1': {name: comment.line.number-sign.source.jcsh}
        '2': {name: comment.line.source.jcsh}
      patterns:
      - include: '#expression'
      - match: \s
      - include: '#invalid-character'

  invalid-character:
    patterns:
    - name: invalid.character.source.jcsh
      match: .

  label:
    patterns:
    - comment: Leading label that can be jumped to using goto
      name: meta.control.label.definition.source.jcsh
      match: ^\s*(\w[\w\-\.]*)\s*(:)
      captures:
        '1': {name: keyword.control.label.definition.source.jcsh}
        '2': {name: punctuation.definition.label.source.jcsh}

  line-continuation:
    patterns:
    - comment: Line continuation
      name: meta.line-continuation.source.jcsh
      begin: (\\)\s*$
      beginCaptures:
        '1': {name: punctuation.line-continuation.source.jcsh}
      end: $
      patterns:
      - include: '#invalid-character'

  modifier:
    patterns:
    - comment: Variable modifier
      name: meta.variable.modifier.source.jcsh
      begin: ;
      beginCaptures:
        '0': {name: punctuation.separator.variable.modifier.source.jcsh}
      end: (?=[;\}])
      patterns:
      - include: '#builtin-modifier'
      - include: '#variable'
      - include: '#nested-call'
      - name: keyword.modifier.user.surrounding.source.jcsh
        match: \s*\w[\w\-\.]*\s*
      - include: '#invalid-character'

  nested-call:
    patterns:
    - comment: Nested call
      name: meta.nested-call.source.jcsh
      begin: (\$)(\()
      beginCaptures:
        '1': {name: punctuation.definition.nested-call.head.source.jcsh}
        '2': {name: punctuation.definition.nested-call.begin.source.jcsh}
      end: \)
      endCaptures:
        '0': {name: punctuation.definition.nested-call.end.source.jcsh}
      patterns:
      - name: meta.nested-call.content.source.jcsh
        begin: (?<=\()
        end: (?<=.)\s*(?=\)|#[^\(]|$|(\\))
        patterns:
        - include: '#callable'
        - include: '#argument'
        - match: \s
        - include: '#invalid-character'
      - include: '#invalid-character'

  number:
    patterns:
    - name: constant.numeric.hexadecimal.source.jcsh
      match: (?<!\w)(0x)?[\da-fA-F]+(?![\w.])
    - name: constant.numeric.decimal.source.jcsh
      match: (?<!\w)\d+(?![\w.])

  operator:
    patterns:
    - name: keyword.operator.source.jcsh
      match: (-|\*|/|%|\+|<<|>>>|>>|<=|<|>=|>|==|!=|!|=~|~|&|\^|\||\.\.|\?)

  plugin-modifier:
    patterns:
    - comment: Modifier for accessing plugin variables
      name: meta.variable.plugin-modifier.source.jcsh
      begin: ':'
      beginCaptures:
        '0': {name: punctuation.separator.variable.modifier.plugin.source.jcsh}
      end: (?=[\[;\}])
      patterns:
      - include: '#variable'
      - include: '#nested-call'
      - name: support.variable.name.plugin.surrounding.source.jcsh
        match: \s*\w[\w\-\.]*\s*
      - include: '#invalid-character'

  positional-variable-name:
    patterns:
    - comment: Name of a positional variable
      name: support.variable.name.positional.source.jcsh
      match: (?<=\{)\s*\d+\s*(?=[\[;\}])

  return-statement:
    patterns:
    - comment: Continue statement
      name: meta.control.continue.source.jcsh
      begin: ^(?:\s*(\w[\w\-\.]*)\s*(:))?\s*(return)
      beginCaptures:
        '1': {name: keyword.control.label.definition.source.jcsh}
        '2': {name: punctuation.definition.label.source.jcsh}
        '3': {name: keyword.control.return.source.jcsh}
      end: \s*(?=(\s#)|$|\\)
      patterns:
      - include: '#expression'
      - match: \s
      - include: '#invalid-character'

  string:
    patterns:
    - comment: Single-quoted string literal without variable replacement and interpolation
      name: meta.string.source.jcsh
      begin: ''''
      beginCaptures:
        '0': {name: punctuation.definition.string.single.begin.source.jcsh}
      end: ''''
      endCaptures:
        '0': {name: punctuation.definition.string.single.end.source.jcsh}
      patterns:
      - name: constant.character.escape.source.jcsh
        match: \\['\\]
      - name: string.quoted.single.surrounding.source.jcsh
        match: .
    - comment: Double-quoted string literal with variable replacement and interpolation
      name: meta.string.source.jcsh
      begin: '"'
      beginCaptures:
        '0': {name: punctuation.definition.string.double.begin.source.jcsh}
      end: '"'
      endCaptures:
        '0': {name: punctuation.definition.string.double.end.source.jcsh}
      patterns:
      - include: '#variable'
      - include: '#nested-call'
      - name: constant.character.escape.source.jcsh
        match: \\[\$"\\]
      - name: string.quoted.double.surrounding.source.jcsh
        match: .

  subscript:
    patterns:
    - comment: Variable subscript
      begin: (\[)
      beginCaptures:
        '1': {name: punctuation.definition.subscript.begin.source.jcsh}
      end: (\])\s*(?=[:\[;\}])
      endCaptures:
        '1': {name: punctuation.definition.subscript.end.source.jcsh}
      patterns:
      - match: \s*\*\s*
        name: punctuation.subscript.content.asterisk.source.jcsh
      - include: '#expression'
      - match: \s*#\s*
        name: punctuation.subscript.content.number-sign.source.jcsh
      - match: \s
      - include: '#invalid-character'

  try-block:
    patterns:
    - comment: Try block
      name: meta.control.try.source.jcsh
      begin: ^(?:\s*(\w[\w\-\.]*)\s*(:))?\s*(try)\s*(?:\s(#)(.*))?$|(\\)
      beginCaptures:
        '1': {name: keyword.control.label.definition.source.jcsh}
        '2': {name: punctuation.definition.label.source.jcsh}
        '3': {name: keyword.control.try.source.jcsh}
        '4': {name: comment.line.number-sign.source.jcsh}
        '5': {name: comment.line.source.jcsh}
      end: ^\s*(end)\s*(?:\s(#)(.*))?$
      endCaptures:
        '1': {name: keyword.control.try.end.source.jcsh}
        '2': {name: comment.line.number-sign.source.jcsh}
        '3': {name: comment.line.source.jcsh}
      patterns:
      - include: '#catch-clause'
      - include: $self

  user-variable-name:
    patterns:
    - comment: User-defined variable name
      name: meta.variable.name.user.source.jcsh
      begin: (?<=\{)\s*
      end: \s*(?=[:\[;\}])
      patterns:
      - include: '#variable'
      - include: '#nested-call'
      - name: variable.name.user.surrounding.source.jcsh
        match: \w[\w\-\.]*
      - include: '#invalid-character'

  variable:
    patterns:
    - comment: Bracket-style variable reference
      name: meta.reference.variable.source.jcsh
      begin: (\$)(\{)
      beginCaptures:
        '1': {name: punctuation.definition.reference.variable.head.source.jcsh}
        '2': {name: punctuation.definition.reference.variable.begin.source.jcsh}
      end: \}
      endCaptures:
        '0': {name: punctuation.definition.reference.variable.end.source.jcsh}
      patterns:
      - include: '#variable-name'
      - include: '#plugin-modifier'
      - include: '#subscript'
      - include: '#modifier'
      - include: '#invalid-character'

  variable-name:
    patterns:
    - comment: Variable name. May contain replaced variables and interpolations
      name: meta.variable.name.source.jcsh
      begin: (?<=\{)
      end: (?=[:\[;\}])
      patterns:
      - include: '#builtin-variable-name'
      - include: '#positional-variable-name'
      - include: '#environment-variable-name'
      - include: '#user-variable-name'
      - include: '#invalid-character'

  while-block:
    patterns:
    - comment: While block
      name: meta.control.while.source.jcsh
      begin: ^(?:\s*(\w[\w\-\.]*)\s*(:))?\s*(while)(?=\s+\S+.*$|(\\))
      beginCaptures:
        '1': {name: keyword.control.label.definition.source.jcsh}
        '2': {name: punctuation.definition.label.source.jcsh}
        '3': {name: keyword.control.while.source.jcsh}
      end: ^\s*(end)\s*(?:\s(#)(.*))?$
      endCaptures:
        '1': {name: keyword.control.while.end.source.jcsh}
        '2': {name: comment.line.number-sign.source.jcsh}
        '3': {name: comment.line.source.jcsh}
      patterns:
      - include: '#while-expression'
      - include: '#break-statement'
      - include: '#continue-statement'
      - include: $self

  while-expression:
    patterns:
    - begin: (?<=while)\s+
      end: \s*(?:\s(#)(.*))?$|(\\)
      endCaptures:
        '1': {name: comment.line.number-sign.source.jcsh}
        '2': {name: comment.line.source.jcsh}
      patterns:
      - include: '#expression'
      - match: \s
      - include: '#invalid-character'

...
